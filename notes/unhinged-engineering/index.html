<!DOCTYPE html>
<html>

<head>
	<title>John Forstmeier</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="@forstmeier">
	<meta name="twitter:title" content="John Forstmeier">
	<meta name="twitter:description" content="Personal website of John Forstmeier">
	<meta name="twitter:image" content="https://johnforstmeier.com/twitter_card.jpg">
	<meta name="twitter:image:alt" content="Profile image">
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="icon" href="/favicon.ico" type="image/x-icon" />
	<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
</head>

<body>
	<div class="container">

<h2>Note - Unhinged Engineering</h2>
<div>
	<p>> 2022-11-04</p>
	<p><p>This is a loose collection of aggressive development process ideas. Some I have implemented and others I haven&rsquo;t although I will as soon as the opportunity arises.</p>
<ol>
<li><strong>Automated testing</strong>: tests are run automatically on each new <code>feature</code> branch and must meet coverage and quality requirements - these should be treated as &ldquo;baseline&rdquo; regression and constantly updated.</li>
<li><strong>Automated process</strong>: between <code>git branch feature</code> and <code>git merge feature</code> no step should be manual - running tests, checking coverage, enforcing formatting, moving stories, alerting testers, and everything else should be automated.</li>
<li><strong>Anti-conveyor belt</strong>: no change is &ldquo;handed off&rdquo; to the next team (e.g. QA) - every proposed change is closely followed by the requesting developer through each step of the process which should ideally be short.</li>
<li><strong>Reverse QA bottleneck</strong>: developers join QA teams in manually reviewing <code>feature</code> branches - this should a) make testing requirements explicit and b) allow developers to immediately understand issues as they are discovered turning a bottleneck into a value-add.</li>
<li><strong>Dual branches</strong>: only <code>master</code> and <code>feature</code> branches exist in the development process - <code>feature</code> branches are created on-demand for each pull request with <code>master</code> as the source of truth protected by merge requirements and is constantly deployed to production from <code>HEAD</code>.</li>
<li><strong>Single pull requests deploys</strong>: a single, logical piece of work attached to a story under the responsibility of a sole developer - this isolates blast radius and decreases complexity in understanding errors as they arise.</li>
<li><strong>Roll forward fixes</strong>: bug in production are fixed via pull request incrementing the release number - rollback strategies are admitting you were wrong while rollforward strategies are declaring you just weren&rsquo;t right yet.</li>
<li><strong>Single file deploys</strong>: individual pull requests contain a single changed production file - this excludes test files and mandates small, incremental deployments.</li>
<li><strong>Test in production</strong>: developers manually testing new features in the production environment - this would come <em>after</em> automated tests on feature branches but is still critical because they&rsquo;re never <em>quite</em> the real thing.</li>
</ol>
<p>This is a non-exhaustive listing but what is here is to encourage <em>speed</em> and <em>dynamism</em> throughout the development cycle.</p>
<blockquote>
<p>Our enemy is entropy</p>
</blockquote>
</p>
	<p>> <a href="/">Home</a></p>
</div>


			<br>
			<br>
		</div>
	</body>
</html>

